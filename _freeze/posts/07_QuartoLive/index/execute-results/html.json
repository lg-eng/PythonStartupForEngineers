{
  "hash": "ff44dbabf69619fb80d60d0d07d41486",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Dynamically execute code in the user's web browser\"\nauthor: \"Leopold GÃ¶tsch\"\ndate: \"2024-10-02\"\nformat: live-html\npyodide:\n  packages:\n    - matplotlib\n    - numpy\n    - pandas\n    - sympy\n    - quantiphy\n#    - re\n    - scipy\nresources:\n  - data\ncategories: [news]\n---\n\n# [Quarto Live](https://r-wasm.github.io/quarto-live/)\nDynamically execute code in the user's web browser by comining [Quarto](www.quarto.org) and [Quarto Live](https://r-wasm.github.io/quarto-live/).\n\n\n# Python\n\nHere is some code to demonstrate the use of Python using Quarto Live. in addition the demonstration code can be used to create nice plots with matplotlib. Feel free to change the code and see the results.  \nthe code bellow is specific to the data exportet froman Altium transient simulation. The code reads the data from a csv file and plots the current and voltage over time.  \nThis method could be a good way to create consistent plots for reports or presentations. As of now it is unclear how data could be uploaded, see [Quarto Live - Loading  Resources](https://r-wasm.github.io/quarto-live/other/resources.html ).\n\n\n\n\n```{pyodide}\nfrom sympy import * # import everything from sympy\nimport sympy.physics.units as u # import the units module\nfrom matplotlib import pyplot as plt # import the pyplot module from matplotlib\nfrom quantiphy import Quantity # import the Quantity class from the quantiphy module\nimport pandas as pd # import the pandas module\nfrom itertools import cycle\n\n\ndef trans_plot_matplotlib(filepath, thing_to_plot): # define a function that takes a filepath and a dictionary of things to plot      \n        #https://matplotlib.org/stable/gallery/ticks/tick-formatters.html \n        from matplotlib.ticker import FuncFormatter # import the FuncFormatter class from the matplotlib.ticker module\n        time_formatter = FuncFormatter(lambda v, p: str(Quantity(v, 's'))) # create a time formatter\n        volt_formatter = FuncFormatter(lambda v, p: str(Quantity(v, 'V'))) # create a voltage formatter\n        amp_formatter =  FuncFormatter(lambda v, p: str(Quantity(v, 'A'))) # create a current formatter\n\n        df = pd.read_csv(filepath,sep=';',decimal=',') # read the csv file at the filepath into a pandas dataframe\n\n        suplotnumber_max = 0 # initialize the maximum subplot number\n        for key in thing_to_plot: # iterate over the keys in the dictionary\n            if max(thing_to_plot[key]) > suplotnumber_max: # check if the maximum value in the list of values is greater than the maximum subplot number\n                suplotnumber_max = max(thing_to_plot[key]) # set the maximum subplot number to the maximum value in the list of values\n        \n        styles = cycle(['--', '-.', ':']) # create a cycle of line styles\n        fig, ax = plt.subplots(suplotnumber_max,1,figsize=(5, 3*suplotnumber_max)) # create a figure and an array of axes\n        plot_numbers = [] # initialize the list of old subplot numbers, required to add the grid and legend only once per subplot\n        for i, key in enumerate(thing_to_plot): # iterate over the keys in the dictionary\n            sub_plot_number = thing_to_plot[key][0]-1 # set the subplot number to the first value in the list of values\n            line, = ax[sub_plot_number].plot(df.time, df[key],label=key) # plot the key against the time\n            ax[sub_plot_number].set_xlabel('Time') # set the x-axis label\n            ax[sub_plot_number].set_ylabel(key) # set the y-axis label\n\n            if sub_plot_number not in plot_numbers: # check if the subplot number is different from the old subplot number\n              ax[sub_plot_number].grid() # add a grid to the subplot\n              ax[sub_plot_number].xaxis.set_major_formatter(time_formatter) # set the x-axis formatter to the time formatter\n              if key[0] == 'i': # check if the first character of the key is 'i'\n                  ax[sub_plot_number].yaxis.set_major_formatter(amp_formatter) # set the y-axis formatter to the current formatter\n              elif key[0] == 'v': # check if the first character of the key is 'v'\n                ax[sub_plot_number].yaxis.set_major_formatter(volt_formatter) # set the y-axis formatter to the voltage formatter\n              ax[sub_plot_number].yaxis_tickformat = \".3s\" # set the y-axis tick format\n              ax[sub_plot_number].xaxis_tickformat = \".3s\" # set the x-axis tick format\n              plot_numbers.append(sub_plot_number) # append the subplot number to the list of old subplot numbers\n            else:\n                line.set_linestyle(next(styles))\n            ax[sub_plot_number].legend() # add a legend to the subplot\n\n        plt.tight_layout() # adjust the subplot layout\n        plt.savefig(filepath.replace('.csv','.svg'))  # save the figure as an svg file\n        plt.show() # show the figure\n\nthing_to_plot = {\"i(rlast)\":[1],\"i(rshunt)\":[2],\"ic(t1)\":[3],\"ic(t2)\":[3],\"v(uin)\":[4],\"v(uout)\":[4]} # define a dictionary of things to plot\ntrans_plot_matplotlib(\"data/trans.csv\", thing_to_plot ) # call the function\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}