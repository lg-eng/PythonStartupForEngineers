{
  "hash": "b7600472eace5deb3d5311f8f57da490",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Dynamically execute code in the user's web browser\"\nauthor: \"Leopold GÃ¶tsch\"\ndate: \"2024-10-02\"\nformat: live-html\npyodide:\n  packages:\n    - matplotlib\n    - numpy\n    - pandas\n    - sympy\n    - quantiphy\n#    - re\n    - scipy\nresources:\n  - data\ncategories: [news]\n---\n\n# [Quarto Live](https://r-wasm.github.io/quarto-live/)\nDynamically execute code in the user's web browser by combining [Quarto](https://www.quarto.org) and [Quarto Live](https://r-wasm.github.io/quarto-live/).  \n\nHere is some code to demonstrate the use of Python using Quarto Live. In addition, the demonstration code can be used to create nice plots with [Matplotlib](https://matplotlib.org/). Feel free to change the code and see the results.  \nThe code bellow is specific to the data exported from an Altium transient simulation. The code reads the data from a csv file and plots specified data over time.  \nThis method could be a good way to create consistent plots for reports or presentations. As of now it is unclear how data could be uploaded, see [Quarto Live - Loading  Resources](https://r-wasm.github.io/quarto-live/other/resources.html ).\n\n\n\n\n```{pyodide}\nfrom sympy import * # import everything from sympy\nimport sympy.physics.units as u # import the units module\nfrom matplotlib import pyplot as plt # import the pyplot module from matplotlib\nfrom quantiphy import Quantity # import the Quantity class from the quantiphy module\nimport pandas as pd # import the pandas module\nfrom itertools import cycle\n\n\ndef trans_plot_matplotlib(df, thing_to_plot): # define a function that takes a filepath and a dictionary of things to plot      \n        #https://matplotlib.org/stable/gallery/ticks/tick-formatters.html \n        from matplotlib.ticker import FuncFormatter # import the FuncFormatter class from the matplotlib.ticker module\n        time_formatter = FuncFormatter(lambda v, p: str(Quantity(v, 's'))) # create a time formatter\n        volt_formatter = FuncFormatter(lambda v, p: str(Quantity(v, 'V'))) # create a voltage formatter\n        amp_formatter =  FuncFormatter(lambda v, p: str(Quantity(v, 'A'))) # create a current formatter\n        pow_formatter =  FuncFormatter(lambda v, p: str(Quantity(v, 'W'))) # create a current formatter\n        percent_formatter =  FuncFormatter(lambda v, p: str(Quantity(v, '%'))) # create a current formatter\n\n        suplotnumber_max = 0 # initialize the maximum subplot number\n        for key in thing_to_plot: # iterate over the keys in the dictionary\n            if max(thing_to_plot[key]) > suplotnumber_max: # check if the maximum value in the list of values is greater than the maximum subplot number\n                suplotnumber_max = max(thing_to_plot[key]) # set the maximum subplot number to the maximum value in the list of values\n        \n        styles = cycle(['--', '-.', ':']) # create a cycle of line styles\n        letters = cycle(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']) # create a cycle of letters\n        fig, ax = plt.subplots(suplotnumber_max,1,figsize=(10, 2*suplotnumber_max)) # create a figure and an array of axes\n        plot_numbers = [] # initialize the list of old subplot numbers, required to add the grid and legend only once per subplot\n        for i, key in enumerate(thing_to_plot): # iterate over the keys in the dictionary\n            sub_plot_number = thing_to_plot[key][0]-1 # set the subplot number to the first value in the list of values\n            line, = ax[sub_plot_number].plot(df.time, df[key],label=key) # plot the key against the time\n            ax[sub_plot_number].set_xlabel('Time') # set the x-axis label\n            \n\n            if sub_plot_number not in plot_numbers: # check if the subplot number is different from the old subplot number\n              ax[sub_plot_number].grid() # add a grid to the subplot\n              ax[sub_plot_number].xaxis.set_major_formatter(time_formatter) # set the x-axis formatter to the time formatter\n              if key[0] == 'i': # check if the first character of the key is 'i'\n                  ax[sub_plot_number].yaxis.set_major_formatter(amp_formatter) # set the y-axis formatter to the current formatter\n                  ax[sub_plot_number].set_ylabel('Current') # set the y-axis label\n              elif key[0] == 'v': # check if the first character of the key is 'v'\n                ax[sub_plot_number].yaxis.set_major_formatter(volt_formatter) # set the y-axis formatter to the voltage formatter\n                ax[sub_plot_number].set_ylabel('Voltage') # set the y-axis label\n              elif key[0] == 'p': # check if the first character of the key is 'p'\n                ax[sub_plot_number].yaxis.set_major_formatter(pow_formatter)\n                ax[sub_plot_number].set_ylabel('Power') # set the y-axis label\n              elif key[0] == 'r': # check if the first character of the key is 'r'\n                ax[sub_plot_number].yaxis.set_major_formatter(percent_formatter)\n                ax[sub_plot_number].set_ylabel('Percentage')\n              ax[sub_plot_number].yaxis_tickformat = \".3s\" # set the y-axis tick format\n              ax[sub_plot_number].xaxis_tickformat = \".3s\" # set the x-axis tick format\n              plot_numbers.append(sub_plot_number) # append the subplot number to the list of old subplot numbers\n              ax[sub_plot_number].set_title('Plot ' + next(letters) + '.') # set the title of the subplot to the next letter\n            else:\n                line.set_linestyle(next(styles))\n            ax[sub_plot_number].legend() # add a legend to the subplot\n            \n\n        plt.tight_layout() # adjust the subplot layout\n        plt.savefig(filepath.replace('.csv','.svg'))  # save the figure as an svg file\n        plt.savefig(filepath.replace('.csv','.png'))  # save the figure as an svg file\n        plt.show() # show the figure\n\nthing_to_plot = {\"i(rlast)\":[1],\"i(rshunt1)\":[2],\"v(uin)\":[3],\"v(uout)\":[3],'v(uin)-v(uout)': [4],'rudiff_perc':[5],'p(rlast)':[6],'p(vin)':[7]} # define a dictionary of things to plot\nfilepath = 'data/1.1_Transient Analysis.csv' # define the filepath\n\ndf = pd.read_csv(filepath,sep=';',decimal=',') # read the csv file at the filepath into a pandas dataframe\ndf['v(uin)-v(uout)'] = df['v(uin)'] - df['v(uout)'] # create a new column in the dataframe that is the difference between the voltage at the input and the voltage at the output\ndf['vdiff_perc'] = ((df['v(uin)'] - df['v(uout)'])/df['v(uin)'])*100 # create a new column in the dataframe that is the percentage difference between the voltage at the input and the voltage at the output\ndf['rudiff_perc'] = df['vdiff_perc'].clip(lower=0,upper=100) # clip the percentage difference between -100 and 100\n\ntrans_plot_matplotlib(df, thing_to_plot ) # call the function\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}